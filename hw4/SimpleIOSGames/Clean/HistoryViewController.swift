//
//  HistoryViewController.swift
//  SimpleIOSGames
//
//  Created by Mike I on 03.06.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol HistoryDisplayLogic: AnyObject
{
    func displayNewDiceResult(viewModel: History.AppendDiceResult.ViewModel)
    func displayDiceResults(viewModel: History.GetListDiceResult.ViewModel)
    func displayNewRPSResult(viewModel: History.AppendRPSResult.ViewModel)
    func displayRPSResults(viewModel: History.GetListRPSResult.ViewModel)
    func displayBestRPSResults(viewModel: History.GetBestRPSResults.ViewModel)
    func displayBestDiceResults(viewModel: History.GetBestDiceResult.ViewModel)
}
protocol HistoryAppendDiceLogic: AnyObject
{
    func appendDiceResult(imageUrl:String)
}
protocol HistoryAppendRPSLogic: AnyObject
{
    func appendRPSResult(round:RPSRound)
}
class HistoryViewController: UIViewController
{
    var interactor: HistoryBusinessLogic?
    var router: (NSObjectProtocol  & HistoryDataPassing)?
    var diceResults: [DiceResult] = []
    var rpsResults: [RPSRoundResult] = []
    var bestRPSResults:RPSRoundResult?
    var bestDiceResults:[(DiceResult,Float)] =
    [
        (DiceResult(id: 1, imageUrl: "die.face.1"),0),
        (DiceResult(id: 2, imageUrl: "die.face.2"),0),
        (DiceResult(id: 3, imageUrl: "die.face.3"),0),
        (DiceResult(id: 4, imageUrl: "die.face.4"),0),
        (DiceResult(id: 5, imageUrl: "die.face.5"),0),
        (DiceResult(id: 6, imageUrl: "die.face.6"),0),
    ]
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    private func setup()
    {
        let viewController = self
        let interactor = HistoryInteractor()
        let presenter = HistoryPresenter()
        let router = HistoryRouter()
        viewController.interactor = interactor
        viewController.router = router as! NSObjectProtocol & HistoryDataPassing
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    private lazy var dataSource = makeDataSource()
    private let collectionView: UICollectionView = {
        let view = UICollectionView(
            frame: .zero,
            collectionViewLayout: CollectionViewLayoutFactory.statisticsLayout())
        view.backgroundColor = .systemYellow
        view.register(UICollectionViewCell.self, forCellWithReuseIdentifier: "cell")
        return view
    }()
    override func viewDidLoad() {
        super.viewDidLoad()
        title = "Statistics"
        addSubviews()
        makeConstraints()
        createSnapshot()
        configureHeaders()
        configureNavigation()
    }
}


extension HistoryViewController: HistoryAppendRPSLogic{
    func appendRPSResult(round:RPSRound) {
        interactor?.appendRPSResult(request: History.AppendRPSResult.Request(round: round))
    }
}


extension HistoryViewController: HistoryAppendDiceLogic{
    func appendDiceResult(imageUrl: String) {
        interactor?.appendDiceResult(request: History.AppendDiceResult.Request(imageUrl: imageUrl))
    }
}


extension HistoryViewController: HistoryDisplayLogic{
    
    
    func displayDiceResults(viewModel: History.GetListDiceResult.ViewModel)
    {
        diceResults = viewModel.diceResults
        createSnapshot()
    }
    func displayNewDiceResult(viewModel: History.AppendDiceResult.ViewModel)
    {
        if(diceResults.isEmpty){
            createSnapshot()
        }
        diceResults.append(viewModel.diceResult)
        var snapshot = dataSource.snapshot(for: .dice)
        snapshot.append([.init(content: .dice(configuration: .init(id: viewModel.diceResult.id, imageUrl: viewModel.diceResult.imageUrl)))])
        dataSource.apply(snapshot, to: .dice,animatingDifferences: true)
        fetchBestDiceResults()
    }
    func displayRPSResults(viewModel: History.GetListRPSResult.ViewModel)
    {
        rpsResults = viewModel.rpsResults
        createSnapshot()
    }
    func displayBestRPSResults(viewModel: History.GetBestRPSResults.ViewModel)
    {
        bestRPSResults = viewModel.rpsResults
        updateBestSection()
    }
    func displayBestDiceResults(viewModel: History.GetBestDiceResult.ViewModel)
    {
        if let newBestDiceResults = viewModel.diceResults{
            bestDiceResults = newBestDiceResults
        }
        updateBestSection()
    }
    func displayNewRPSResult(viewModel: History.AppendRPSResult.ViewModel)
    {
        if(rpsResults.isEmpty){
            createSnapshot()
        }
        rpsResults.append(viewModel.rpsResult)
        var snapshot = dataSource.snapshot(for: .rps)
        snapshot.append([.init(content: .rps(configuration: .init(id: viewModel.rpsResult.id, round: viewModel.rpsResult.round)))])
        dataSource.apply(snapshot, to: .rps,animatingDifferences: true)
        fetchBestRPSResults()
    }
    func fetchBestRPSResults()
    {
        let request = History.GetBestRPSResults.Request()
        interactor?.fetchBestRPSResults(request: request)
    }
    func fetchBestDiceResults()
    {
        let request = History.GetBestDiceResult.Request()
        interactor?.fetchBestDiceResults(request: request)
    }
}


private extension HistoryViewController {
    func addSubviews() {
        view.addSubview(collectionView)
    }
    func makeConstraints() {
        collectionView.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            collectionView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            collectionView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            collectionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ])
    }
    func updateBestSection(){
        var snapshot = dataSource.snapshot()
        snapshot.deleteSections([.best])
        snapshot.insertSections([.best], beforeSection: .rps)
        if let bestRPSResults = bestRPSResults {
            snapshot.appendItems([
                .init(content: .rps(configuration: .init(id: bestRPSResults.id, round: bestRPSResults.round)))
            ], toSection: .best)
        }
        snapshot.appendItems([
            .init(content: .dicePercentages(configuration: .init(id: 0, statistics: bestDiceResults)))
        ], toSection: .best)
        dataSource.apply(snapshot,animatingDifferences: true)
    }
    func makeDataSource() -> UICollectionViewDiffableDataSource<StatisticsSectionType, ResultCollectionItem> {
        let dataSource = UICollectionViewDiffableDataSource<
            StatisticsSectionType, ResultCollectionItem
        >(collectionView: collectionView) { [weak self] collectionView, indexPath, item in
            
            guard let section = self?.dataSource.sectionIdentifier(for: indexPath.section) else {
                return .init(frame: .zero)
            }
            return self?.createRecentCell(with: item.content, for: indexPath)
        }
        
        return dataSource
    }
    
    func configureNavigation(){
        navigationController?.navigationBar.prefersLargeTitles = true
        view.backgroundColor = .systemYellow
        let appearance = UINavigationBarAppearance()
        appearance.backgroundColor = .black
        appearance.titleTextAttributes = [.foregroundColor: UIColor.systemYellow]
        appearance.largeTitleTextAttributes = [.foregroundColor: UIColor.systemYellow]
        navigationController?.navigationBar.standardAppearance = appearance
        navigationController?.navigationBar.compactAppearance = appearance
        navigationController?.navigationBar.scrollEdgeAppearance = appearance
    }
    func createSnapshot() {
        var snapshot = NSDiffableDataSourceSnapshot<StatisticsSectionType, ResultCollectionItem>()
        snapshot.appendSections([.best,.rps,.dice])
        snapshot.appendItems(rpsResults.map { result in
                .init(content: .rps(configuration: .init(id: result.id, round: result.round)))
        }, toSection: .rps)
        snapshot.appendItems(diceResults.map { result in
                .init(content: .dice(
                    configuration: .init(id: result.id, imageUrl: result.imageUrl)
                )
                )
        }, toSection: .dice)
        if let bestRPSResults = bestRPSResults {
            print(bestRPSResults)
            snapshot.appendItems([
                .init(content: .rps(configuration: .init(id: bestRPSResults.id, round: bestRPSResults.round)))
            ], toSection: .best)
        }
        snapshot.appendItems([
            .init(content: .dicePercentages(configuration: .init(id: 0, statistics: bestDiceResults)))
        ], toSection: .best)
        dataSource.applySnapshotUsingReloadData(snapshot)
    }
    
    func configureHeaders() {
        var header:UICollectionView.SupplementaryRegistration<HeaderView> = UICollectionView.SupplementaryRegistration<HeaderView>(elementKind: UICollectionView.elementKindSectionHeader) { (supplementaryView, title, indexPath) in
            switch self.dataSource.snapshot().sectionIdentifiers[indexPath.section]{
            case .best:
                supplementaryView.titleLabel.text = "Лучший сет и статистика"
            case .rps:
                supplementaryView.titleLabel.text = "История Rock-Scissors-Paper"
            case .dice:
                supplementaryView.titleLabel.text = "История выпадения кубика"
            }
            supplementaryView.titleLabel.textAlignment = .left
        }
        dataSource.supplementaryViewProvider = { (
            collectionView: UICollectionView,
            kind: String,
            indexPath: IndexPath) -> UICollectionReusableView? in
            let header: HeaderView = collectionView.dequeueConfiguredReusableSupplementary(using: header, for: indexPath)
            return header
        }
    }
    func createRecentCell(with item: ResultCollectionItem.ItemType, for indexPath: IndexPath) -> UICollectionViewCell? {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "cell", for: indexPath)
        switch item {
        case .rps(configuration: let configuration):
            cell.contentConfiguration = configuration
        case .dice(configuration: let configuration):
            cell.contentConfiguration = configuration
        case .dicePercentages(configuration: let configuration):
            cell.contentConfiguration = configuration
        }
        return cell
    }
    
}
